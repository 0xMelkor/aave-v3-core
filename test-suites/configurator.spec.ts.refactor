import { expect } from 'chai';
import { BigNumber } from 'ethers';
import { RAY, ZERO_ADDRESS } from '../helpers/constants';
import { evmRevert, evmSnapshot } from '../helpers/misc-utils';
import { ProtocolErrors } from '../helpers/types';
import { strategyWETH } from '../market-config/reservesConfigs';
import { TestEnv, makeSuite, SignerWithAddress } from './helpers/make-suite';

type ReserveConfigurationValues = {
  reserveDecimals: string;
  baseLTVAsCollateral: string;
  liquidationThreshold: string;
  liquidationBonus: string;
  reserveFactor: string;
  usageAsCollateralEnabled: boolean;
  borrowingEnabled: boolean;
  stableBorrowRateEnabled: boolean;
  isActive: boolean;
  isFrozen: boolean;
  borrowCap: string;
  supplyCap: string;
};

const expectReserveConfigurationData = (
  reserveCfg: {
    decimals: BigNumber;
    ltv: BigNumber;
    liquidationThreshold: BigNumber;
    liquidationBonus: BigNumber;
    reserveFactor: BigNumber;
    usageAsCollateralEnabled: boolean;
    borrowingEnabled: boolean;
    stableBorrowRateEnabled: boolean;
    isActive: boolean;
    isFrozen: boolean;
  },
  capsCfg: {
    borrowCap: BigNumber;
    supplyCap: BigNumber;
  },
  values: ReserveConfigurationValues
) => {
  expect(reserveCfg.decimals).to.be.eq(values.reserveDecimals, 'reserveDecimals is not correct');
  expect(reserveCfg.ltv).to.be.eq(values.baseLTVAsCollateral, 'ltv is not correct');
  expect(reserveCfg.liquidationThreshold).to.be.eq(
    values.liquidationThreshold,
    'liquidationThreshold is not correct'
  );
  expect(reserveCfg.liquidationBonus).to.be.eq(
    values.liquidationBonus,
    'liquidationBonus is not correct'
  );
  expect(reserveCfg.reserveFactor).to.be.eq(values.reserveFactor, 'reserveFactor is not correct');
  expect(reserveCfg.usageAsCollateralEnabled).to.be.eq(
    values.usageAsCollateralEnabled,
    'usageAsCollateralEnabled is not correct'
  );
  expect(reserveCfg.borrowingEnabled).to.be.eq(
    values.borrowingEnabled,
    'borrowingEnabled is not correct'
  );
  expect(reserveCfg.stableBorrowRateEnabled).to.be.eq(
    values.stableBorrowRateEnabled,
    'stableBorrowRateEnabled is not correct'
  );
  expect(reserveCfg.isActive).to.be.eq(values.isActive, 'isActive is not correct');
  expect(reserveCfg.isFrozen).to.be.eq(values.isFrozen, 'isFrozen is not correct');
  expect(capsCfg.borrowCap).to.be.eq(values.borrowCap, 'borrowCap is not correct');
  expect(capsCfg.supplyCap).to.be.eq(values.supplyCap, 'supplyCap is not correct');
};

const shouldBeDoableByRiskOrPoolAdmin = async (
  testTitle: string,
  testEnv: TestEnv,
  baseConfigValues: ReserveConfigurationValues,
  admin: SignerWithAddress
) => {
  describe('', async () => {
    context(testTitle, async () => {
      let snapId;
      before(async () => {
        snapId = await evmSnapshot();
      });
      after(async () => {
        await evmRevert(snapId);
      });

      it('Freezes the ETH reserve', async () => {
        const { configurator, weth, helpersContract } = testEnv;

        expect(await configurator.connect(admin.signer).freezeReserve(weth.address))
          .to.emit(configurator, 'ReserveFrozen')
          .withArgs(weth.address);
        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          isFrozen: true,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Unfreezes the ETH reserve', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        expect(await configurator.connect(admin.signer).unfreezeReserve(weth.address))
          .to.emit(configurator, 'ReserveUnfrozen')
          .withArgs(weth.address);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, { ...baseConfigValues });
        expect(isPaused).to.be.equal(false);
      });

      it('Deactivates the ETH reserve for borrowing', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        expect(await configurator.connect(admin.signer).disableBorrowingOnReserve(weth.address))
          .to.emit(configurator, 'BorrowingDisabledOnReserve')
          .withArgs(weth.address);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          borrowingEnabled: false,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Activates the ETH reserve for borrowing', async () => {
        const { configurator, weth, helpersContract } = testEnv;
        expect(
          await configurator.connect(admin.signer).enableBorrowingOnReserve(weth.address, '0', true)
        )
          .to.emit(configurator, 'BorrowingEnabledOnReserve')
          .withArgs(weth.address, true);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);
        const { variableBorrowIndex } = await helpersContract.getReserveData(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
        });
        expect(isPaused).to.be.equal(false);
        expect(variableBorrowIndex.toString()).to.be.equal(RAY);
      });

      it('Deactivates the ETH reserve as collateral', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        expect(
          await configurator
            .connect(admin.signer)
            .configureReserveAsCollateral(weth.address, 0, 0, 0)
        )
          .to.emit(configurator, 'CollateralConfigurationChanged')
          .withArgs(weth.address, 0, 0, 0);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          baseLTVAsCollateral: '0',
          liquidationThreshold: '0',
          liquidationBonus: '0',
          usageAsCollateralEnabled: false,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Activates the ETH reserve as collateral', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        expect(
          await configurator
            .connect(admin.signer)
            .configureReserveAsCollateral(weth.address, '8000', '8250', '10500')
        )
          .to.emit(configurator, 'CollateralConfigurationChanged')
          .withArgs(weth.address, '8000', '8250', '10500');

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          baseLTVAsCollateral: '8000',
          liquidationThreshold: '8250',
          liquidationBonus: '10500',
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Disable stable borrow rate on the ETH reserve', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        expect(await configurator.connect(admin.signer).disableReserveStableRate(weth.address))
          .to.emit(configurator, 'StableRateDisabledOnReserve')
          .withArgs(weth.address);
        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          stableBorrowRateEnabled: false,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Enables stable borrow rate on the ETH reserve', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        expect(await configurator.connect(admin.signer).enableReserveStableRate(weth.address))
          .to.emit(configurator, 'StableRateEnabledOnReserve')
          .withArgs(weth.address);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Changes the reserve factor of WETH', async () => {
        const { configurator, helpersContract, weth } = testEnv;

        const newReserveFactor = '1000';
        expect(
          await configurator.connect(admin.signer).setReserveFactor(weth.address, newReserveFactor)
        )
          .to.emit(configurator, 'ReserveFactorChanged')
          .withArgs(weth.address, newReserveFactor);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          reserveFactor: newReserveFactor,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Updates the ReserveInterestRateStrategy address of WETH', async () => {
        const { pool, configurator, weth } = testEnv;

        const before = await pool.getReserveData(weth.address);

        expect(
          await configurator
            .connect(admin.signer)
            .setReserveInterestRateStrategyAddress(weth.address, ZERO_ADDRESS)
        )
          .to.emit(configurator, 'ReserveInterestRateStrategyChanged')
          .withArgs(weth.address, ZERO_ADDRESS);
        const after = await pool.getReserveData(weth.address);

        expect(before.interestRateStrategyAddress).to.not.be.eq(ZERO_ADDRESS);
        expect(after.interestRateStrategyAddress).to.be.eq(ZERO_ADDRESS);
      });

      it('Updates the borrowCap of WETH', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const newBorrowCap = '3000000';
        expect(await configurator.connect(admin.signer).setBorrowCap(weth.address, newBorrowCap))
          .to.emit(configurator, 'BorrowCapChanged')
          .withArgs(weth.address, newBorrowCap);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          borrowCap: newBorrowCap,
        });
        expect(isPaused).to.be.equal(false);
      });

      it('Updates the supplyCap of WETH', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const newBorrowCap = '3000000';
        const newSupplyCap = '3000000';
        expect(await configurator.connect(admin.signer).setSupplyCap(weth.address, newSupplyCap))
          .to.emit(configurator, 'SupplyCapChanged')
          .withArgs(weth.address, newSupplyCap);

        const configData = await helpersContract.getReserveConfigurationData(weth.address);
        const reserveCaps = await helpersContract.getReserveCaps(weth.address);
        const isPaused = await helpersContract.getPaused(weth.address);

        expectReserveConfigurationData(configData, reserveCaps, {
          ...baseConfigValues,
          borrowCap: newBorrowCap,
          supplyCap: newSupplyCap,
        });
        expect(isPaused).to.be.equal(false);
      });
    });
  });
};

makeSuite('PoolConfigurator', (testEnv: TestEnv) => {
  const {
    PC_RESERVE_LIQUIDITY_NOT_0,
    RC_INVALID_BORROW_CAP,
    RC_INVALID_SUPPLY_CAP,
    PC_FLASHLOAN_PREMIUMS_MISMATCH,
    PC_FLASHLOAN_PREMIUM_INVALID,
  } = ProtocolErrors;

  let baseConfigValues: ReserveConfigurationValues;

  before(() => {
    const {
      reserveDecimals,
      baseLTVAsCollateral,
      liquidationThreshold,
      liquidationBonus,
      reserveFactor,
      borrowingEnabled,
      stableBorrowRateEnabled,
      borrowCap,
      supplyCap,
    } = strategyWETH;
    baseConfigValues = {
      reserveDecimals,
      baseLTVAsCollateral,
      liquidationThreshold,
      liquidationBonus,
      reserveFactor,
      usageAsCollateralEnabled: true,
      borrowingEnabled,
      stableBorrowRateEnabled,
      isActive: true,
      isFrozen: false,
      borrowCap: borrowCap,
      supplyCap: supplyCap,
    };
  });

  describe('Test callable functions by onlyRiskOrPoolAdmins', async () => {
    it('Calls by RiskAdmin', async () => {
      const { riskAdmin } = testEnv;
      await shouldBeDoableByRiskOrPoolAdmin('RiskAdmin', testEnv, baseConfigValues, riskAdmin);
    });
    it('Calls by PoolAdmin', async () => {
      const { poolAdmin } = testEnv;
      await shouldBeDoableByRiskOrPoolAdmin('PoolAdmin', testEnv, baseConfigValues, poolAdmin);
    });
  });

  it('Deactivates the ETH reserve', async () => {
    const { configurator, weth, helpersContract } = testEnv;
    expect(await configurator.deactivateReserve(weth.address));
    const { isActive } = await helpersContract.getReserveConfigurationData(weth.address);
    expect(isActive).to.be.equal(false);
  });

  it('Reactivates the ETH reserve', async () => {
    const { configurator, weth, helpersContract } = testEnv;
    expect(await configurator.activateReserve(weth.address));
    const { isActive } = await helpersContract.getReserveConfigurationData(weth.address);
    expect(isActive).to.be.equal(true);
  });

  it('Pauses the ETH reserve by pool admin', async () => {
    const { configurator, weth, helpersContract, addressesProvider } = testEnv;
    expect(await configurator.signer.getAddress()).to.be.equal(
      await addressesProvider.getPoolAdmin()
    );
    expect(await configurator.setReservePause(weth.address, true))
      .to.emit(configurator, 'ReservePaused')
      .withArgs(weth.address);
    const configData = await helpersContract.getReserveConfigurationData(weth.address);
    const reserveCaps = await helpersContract.getReserveCaps(weth.address);
    const isPaused = await helpersContract.getPaused(weth.address);

    expectReserveConfigurationData(configData, reserveCaps, { ...baseConfigValues });
    expect(isPaused).to.be.equal(true);
  });

  it('Unpauses the ETH reserve by pool admin', async () => {
    const { configurator, helpersContract, weth } = testEnv;
    expect(await configurator.setReservePause(weth.address, false))
      .to.emit(configurator, 'ReserveUnpaused')
      .withArgs(weth.address);

    const configData = await helpersContract.getReserveConfigurationData(weth.address);
    const reserveCaps = await helpersContract.getReserveCaps(weth.address);
    const isPaused = await helpersContract.getPaused(weth.address);

    expectReserveConfigurationData(configData, reserveCaps, { ...baseConfigValues });
    expect(isPaused).to.be.equal(false);
  });

  it('Pauses the ETH reserve by emergency admin', async () => {
    const { configurator, weth, helpersContract, emergencyAdmin } = testEnv;
    expect(await configurator.connect(emergencyAdmin.signer).setReservePause(weth.address, true))
      .to.emit(configurator, 'ReservePaused')
      .withArgs(weth.address);

    const configData = await helpersContract.getReserveConfigurationData(weth.address);
    const reserveCaps = await helpersContract.getReserveCaps(weth.address);
    const isPaused = await helpersContract.getPaused(weth.address);

    expectReserveConfigurationData(configData, reserveCaps, { ...baseConfigValues });
    expect(isPaused).to.be.equal(true);
  });

  it('Unpauses the ETH reserve by emergency admin', async () => {
    const { configurator, helpersContract, weth, emergencyAdmin } = testEnv;
    expect(await configurator.connect(emergencyAdmin.signer).setReservePause(weth.address, false))
      .to.emit(configurator, 'ReserveUnpaused')
      .withArgs(weth.address);

    const configData = await helpersContract.getReserveConfigurationData(weth.address);
    const reserveCaps = await helpersContract.getReserveCaps(weth.address);
    const isPaused = await helpersContract.getPaused(weth.address);

    expectReserveConfigurationData(configData, reserveCaps, { ...baseConfigValues });
    expect(isPaused).to.be.equal(false);
  });

  it('Register a new risk admin', async () => {
    const { configurator, users, riskAdmin } = testEnv;
    expect(await configurator.registerRiskAdmin(users[3].address))
      .to.emit(configurator, 'RiskAdminRegistered')
      .withArgs(users[3].address);

    const isRiskAdminRegistered = await configurator.isRiskAdmin(riskAdmin.address);
    const isNewRegistered = await configurator.isRiskAdmin(users[3].address);
    expect(isNewRegistered).to.be.true;
    expect(isRiskAdminRegistered).to.be.true;
  });

  it('Unregister risk admins', async () => {
    const { configurator, users, riskAdmin } = testEnv;
    expect(await configurator.unregisterRiskAdmin(users[3].address))
      .to.emit(configurator, 'RiskAdminUnregistered')
      .withArgs(users[3].address);
    expect(await configurator.unregisterRiskAdmin(riskAdmin.address))
      .to.emit(configurator, 'RiskAdminUnregistered')
      .withArgs(riskAdmin.address);

    const isRiskAdminRegistered = await configurator.isRiskAdmin(riskAdmin.address);
    const isNewRegistered = await configurator.isRiskAdmin(users[3].address);
    expect(isNewRegistered).to.be.false;
    expect(isRiskAdminRegistered).to.be.false;
  });

  it('Authorized a new flash borrower', async () => {
    const { pool, configurator, users } = testEnv;
    expect(await configurator.authorizeFlashBorrower(users[4].address))
      .to.emit(configurator, 'FlashBorrowerAuthorized')
      .withArgs(users[4].address);

    const isFlashBorrowerAuthorized = await pool.isFlashBorrowerAuthorized(users[4].address);
    expect(isFlashBorrowerAuthorized).to.be.true;
  });

  it('Unauthorized flash borrower', async () => {
    const { pool, configurator, users } = testEnv;
    expect(await configurator.unauthorizeFlashBorrower(users[4].address))
      .to.emit(configurator, 'FlashBorrowerUnauthorized')
      .withArgs(users[4].address);

    const isFlashBorrowerAuthorized = await pool.isFlashBorrowerAuthorized(users[4].address);
    expect(isFlashBorrowerAuthorized).to.be.false;
  });

  it('Updates flash loan premiums: 10 toProtocol, 40 total', async () => {
    const { pool, configurator } = testEnv;
    const newPremiumTotal = 40;
    const newPremiumToProtocol = 10;

    expect(await configurator.updateFlashloanPremiumTotal(newPremiumTotal))
      .to.emit(configurator, 'FlashloanPremiumTotalUpdated')
      .withArgs(newPremiumTotal);
    expect(await configurator.updateFlashloanPremiumToProtocol(newPremiumToProtocol))
      .to.emit(configurator, 'FlashloanPremiumToProcolUpdated')
      .withArgs(newPremiumToProtocol);

    expect(await pool.FLASHLOAN_PREMIUM_TOTAL()).to.be.eq(newPremiumTotal);
    expect(await pool.FLASHLOAN_PREMIUM_TO_PROTOCOL()).to.be.eq(newPremiumToProtocol);
  });
});
